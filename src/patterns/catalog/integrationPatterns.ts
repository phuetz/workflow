/**
 * Integration Patterns (10 patterns)
 * System integration and API patterns
 */

import type { PatternDefinition } from '../../types/patterns';
import {
  createPatternDefinition,
  createPatternStructure,
  createEdgePattern,
  PatternConstraints,
} from '../PatternDefinition';

export const API_GATEWAY: PatternDefinition = createPatternDefinition({
  id: 'api-gateway',
  name: 'API Gateway',
  category: 'integration',
  complexity: 'advanced',
  description: 'Single entry point for all client requests, routing to appropriate services',
  problem: 'Need unified access to multiple microservices with cross-cutting concerns',
  solution:
    'Central gateway handling routing, authentication, rate limiting, and request transformation',
  benefits: [
    'Single entry point',
    'Centralized security',
    'Protocol translation',
    'Request aggregation',
  ],
  tradeoffs: [
    'Single point of failure',
    'Potential bottleneck',
    'Increased complexity',
    'Additional latency',
  ],
  useCases: [
    'Microservices architecture',
    'Mobile backend',
    'Public API management',
    'Multi-tenant systems',
  ],
  tags: ['integration', 'gateway', 'routing', 'security'],
  structure: createPatternStructure({
    minNodes: 4,
    requiredNodeTypes: ['webhook', 'http-request', 'switch'],
    optionalNodeTypes: ['auth', 'rate-limit'],
    requiredEdges: [createEdgePattern('gateway', 'service', 'conditional')],
    topology: 'star',
    constraints: [PatternConstraints.nodeCount(4)],
  }),
  examples: [],
  antiPatterns: ['god-gateway', 'no-rate-limiting'],
  relatedPatterns: ['backend-for-frontend', 'service-mesh'],
  documentation: 'Central gateway routes requests to appropriate backend services.',
});

export const BACKEND_FOR_FRONTEND: PatternDefinition = createPatternDefinition({
  id: 'backend-for-frontend',
  name: 'Backend for Frontend (BFF)',
  category: 'integration',
  complexity: 'advanced',
  description: 'Dedicated backend optimized for specific frontend needs',
  problem: 'Different frontends need different data shapes and aggregations',
  solution: 'Create separate backend services tailored for each frontend type',
  benefits: [
    'Frontend-optimized APIs',
    'Independent scaling',
    'Reduced over-fetching',
    'Team autonomy',
  ],
  tradeoffs: [
    'Code duplication',
    'More services to maintain',
    'Coordination overhead',
    'Increased complexity',
  ],
  useCases: [
    'Mobile and web different needs',
    'Multi-platform applications',
    'Partner integrations',
    'Progressive web apps',
  ],
  tags: ['integration', 'frontend', 'api', 'optimization'],
  structure: createPatternStructure({
    minNodes: 3,
    requiredNodeTypes: ['webhook', 'http-request'],
    optionalNodeTypes: ['aggregate', 'transform'],
    requiredEdges: [createEdgePattern('bff', 'backend', 'sequential')],
    topology: 'linear',
    constraints: [PatternConstraints.nodeCount(3)],
  }),
  examples: [],
  antiPatterns: ['one-size-fits-all-api'],
  relatedPatterns: ['api-gateway', 'adapter'],
  documentation: 'Frontend-specific backend aggregates and transforms data.',
});

export const SERVICE_MESH: PatternDefinition = createPatternDefinition({
  id: 'service-mesh',
  name: 'Service Mesh',
  category: 'integration',
  complexity: 'expert',
  description: 'Infrastructure layer for service-to-service communication',
  problem: 'Need to manage complex service communication with observability and security',
  solution: 'Use sidecar proxies for all service communication with centralized control',
  benefits: [
    'Observability',
    'Traffic management',
    'Security',
    'Resilience',
  ],
  tradeoffs: [
    'High complexity',
    'Resource overhead',
    'Learning curve',
    'Operational burden',
  ],
  useCases: [
    'Microservices at scale',
    'Multi-cloud deployments',
    'Zero-trust security',
    'Canary deployments',
  ],
  tags: ['integration', 'infrastructure', 'observability', 'security'],
  structure: createPatternStructure({
    minNodes: 5,
    requiredNodeTypes: ['http-request'],
    optionalNodeTypes: ['circuit-breaker', 'retry'],
    requiredEdges: [createEdgePattern('service', 'proxy', 'sequential')],
    topology: 'mesh',
    constraints: [PatternConstraints.nodeCount(5)],
  }),
  examples: [],
  antiPatterns: ['direct-service-calls', 'no-observability'],
  relatedPatterns: ['sidecar', 'circuit-breaker'],
  documentation: 'Sidecar proxies handle all service communication.',
});

export const ADAPTER: PatternDefinition = createPatternDefinition({
  id: 'adapter',
  name: 'Adapter Pattern',
  category: 'integration',
  complexity: 'beginner',
  description: 'Convert interface of a service to match what client expects',
  problem: 'Need to integrate incompatible interfaces',
  solution: 'Create adapter layer that translates between interfaces',
  benefits: [
    'Interface compatibility',
    'Legacy system integration',
    'Decoupled systems',
    'Reusable adapters',
  ],
  tradeoffs: [
    'Additional layer',
    'Mapping maintenance',
    'Performance overhead',
    'Complexity',
  ],
  useCases: [
    'Legacy system integration',
    'Third-party API integration',
    'Database abstraction',
    'Protocol conversion',
  ],
  tags: ['integration', 'compatibility', 'translation', 'wrapper'],
  structure: createPatternStructure({
    minNodes: 2,
    requiredNodeTypes: ['function', 'http-request'],
    optionalNodeTypes: ['set', 'transform'],
    requiredEdges: [createEdgePattern('adapter', 'service', 'sequential')],
    topology: 'linear',
    constraints: [PatternConstraints.nodeCount(2)],
  }),
  examples: [],
  antiPatterns: ['tight-coupling', 'leaky-abstraction'],
  relatedPatterns: ['facade', 'message-translator'],
  documentation: 'Adapts one interface to another for compatibility.',
});

export const FACADE: PatternDefinition = createPatternDefinition({
  id: 'facade',
  name: 'Facade Pattern',
  category: 'integration',
  complexity: 'intermediate',
  description: 'Provide simplified interface to complex subsystem',
  problem: 'Complex subsystem with multiple interfaces is hard to use',
  solution: 'Create unified interface that hides subsystem complexity',
  benefits: [
    'Simplified interface',
    'Reduced coupling',
    'Easier to use',
    'Shields complexity',
  ],
  tradeoffs: [
    'Additional layer',
    'Potential limitations',
    'Maintenance overhead',
    'Can hide useful features',
  ],
  useCases: [
    'Complex API simplification',
    'Multi-step operations',
    'Legacy system access',
    'Library wrappers',
  ],
  tags: ['integration', 'simplification', 'interface', 'abstraction'],
  structure: createPatternStructure({
    minNodes: 3,
    requiredNodeTypes: ['function', 'http-request'],
    optionalNodeTypes: ['aggregate'],
    requiredEdges: [createEdgePattern('facade', 'subsystem', 'sequential')],
    topology: 'tree',
    constraints: [PatternConstraints.nodeCount(3)],
  }),
  examples: [],
  antiPatterns: ['god-facade', 'leaky-abstraction'],
  relatedPatterns: ['adapter', 'api-gateway'],
  documentation: 'Simplified interface to complex subsystem.',
});

export const WEBHOOK_INTEGRATION: PatternDefinition = createPatternDefinition({
  id: 'webhook-integration',
  name: 'Webhook Integration',
  category: 'integration',
  complexity: 'beginner',
  description: 'Receive real-time notifications from external systems via HTTP callbacks',
  problem: 'Need real-time updates from external systems without polling',
  solution: 'Register webhook endpoint to receive HTTP callbacks when events occur',
  benefits: [
    'Real-time updates',
    'No polling overhead',
    'Event-driven',
    'Scalable',
  ],
  tradeoffs: [
    'Endpoint security',
    'Retry handling',
    'Delivery guarantees',
    'Debugging challenges',
  ],
  useCases: [
    'Payment notifications',
    'GitHub/GitLab events',
    'CRM updates',
    'Monitoring alerts',
  ],
  tags: ['integration', 'webhook', 'real-time', 'event-driven'],
  structure: createPatternStructure({
    minNodes: 2,
    requiredNodeTypes: ['webhook'],
    optionalNodeTypes: ['filter', 'http-request'],
    requiredEdges: [createEdgePattern('webhook', 'handler', 'sequential')],
    topology: 'linear',
    constraints: [PatternConstraints.requiresNodeType('webhook')],
  }),
  examples: [],
  antiPatterns: ['polling-instead-of-webhook', 'no-signature-validation'],
  relatedPatterns: ['event-driven', 'pub-sub'],
  documentation: 'Receives HTTP callbacks from external systems.',
});

export const ANTI_CORRUPTION_LAYER: PatternDefinition = createPatternDefinition({
  id: 'anti-corruption-layer',
  name: 'Anti-Corruption Layer',
  category: 'integration',
  complexity: 'advanced',
  description: 'Isolate system from external dependencies to prevent model corruption',
  problem: 'External systems can corrupt your domain model',
  solution: 'Create translation layer that maps between your model and external models',
  benefits: [
    'Model isolation',
    'Independence',
    'Clean boundaries',
    'Easier testing',
  ],
  tradeoffs: [
    'Additional complexity',
    'Mapping maintenance',
    'Performance overhead',
    'Development effort',
  ],
  useCases: [
    'Legacy system integration',
    'Third-party API integration',
    'Domain model protection',
    'Bounded contexts',
  ],
  tags: ['integration', 'isolation', 'domain', 'boundary'],
  structure: createPatternStructure({
    minNodes: 3,
    requiredNodeTypes: ['function', 'http-request'],
    optionalNodeTypes: ['validation', 'transform'],
    requiredEdges: [createEdgePattern('acl', 'external', 'sequential')],
    topology: 'linear',
    constraints: [PatternConstraints.nodeCount(3)],
  }),
  examples: [],
  antiPatterns: ['leaky-abstraction', 'model-corruption'],
  relatedPatterns: ['adapter', 'facade'],
  documentation: 'Protects domain model from external system corruption.',
});

export const STRANGLER_FIG: PatternDefinition = createPatternDefinition({
  id: 'strangler-fig',
  name: 'Strangler Fig',
  category: 'integration',
  complexity: 'advanced',
  description: 'Gradually migrate legacy system by building new system around it',
  problem: 'Need to replace legacy system without big-bang rewrite',
  solution: 'Incrementally replace functionality while routing requests to old or new system',
  benefits: [
    'Incremental migration',
    'Lower risk',
    'Continuous operation',
    'Gradual learning',
  ],
  tradeoffs: [
    'Complex routing',
    'Dual maintenance',
    'Extended migration period',
    'Consistency challenges',
  ],
  useCases: [
    'Legacy modernization',
    'Platform migration',
    'Technology upgrades',
    'System replacement',
  ],
  tags: ['integration', 'migration', 'legacy', 'gradual'],
  structure: createPatternStructure({
    minNodes: 4,
    requiredNodeTypes: ['switch', 'http-request'],
    optionalNodeTypes: ['feature-flag'],
    requiredEdges: [createEdgePattern('router', 'old-new', 'conditional')],
    topology: 'branching',
    constraints: [PatternConstraints.nodeCount(4)],
  }),
  examples: [],
  antiPatterns: ['big-bang-rewrite'],
  relatedPatterns: ['feature-toggle', 'blue-green-deployment'],
  documentation: 'Gradually replaces legacy system with new implementation.',
});

export const SIDECAR: PatternDefinition = createPatternDefinition({
  id: 'sidecar',
  name: 'Sidecar Pattern',
  category: 'integration',
  complexity: 'advanced',
  description: 'Deploy helper components alongside main application',
  problem: 'Need to add cross-cutting functionality without modifying main application',
  solution: 'Deploy auxiliary services alongside main application in same execution context',
  benefits: [
    'Separation of concerns',
    'Polyglot support',
    'Independent updates',
    'Resource isolation',
  ],
  tradeoffs: [
    'Resource overhead',
    'Deployment complexity',
    'Inter-process communication',
    'Coordination needed',
  ],
  useCases: [
    'Logging and monitoring',
    'Configuration management',
    'Service mesh proxies',
    'Secret management',
  ],
  tags: ['integration', 'deployment', 'cross-cutting', 'auxiliary'],
  structure: createPatternStructure({
    minNodes: 3,
    requiredNodeTypes: ['http-request'],
    optionalNodeTypes: ['monitoring', 'logging'],
    requiredEdges: [createEdgePattern('main', 'sidecar', 'parallel')],
    topology: 'dag',
    constraints: [PatternConstraints.nodeCount(3)],
  }),
  examples: [],
  antiPatterns: ['god-service'],
  relatedPatterns: ['service-mesh', 'ambassador'],
  documentation: 'Helper service deployed alongside main application.',
});

export const AMBASSADOR: PatternDefinition = createPatternDefinition({
  id: 'ambassador',
  name: 'Ambassador Pattern',
  category: 'integration',
  complexity: 'intermediate',
  description: 'Proxy that handles connectivity concerns for client applications',
  problem: 'Need to offload connectivity concerns like retry, circuit breaker, monitoring',
  solution: 'Use ambassador proxy to handle all external communication',
  benefits: [
    'Simplified client code',
    'Centralized connectivity logic',
    'Language-agnostic',
    'Easier testing',
  ],
  tradeoffs: [
    'Additional network hop',
    'Proxy management',
    'Failure point',
    'Resource usage',
  ],
  useCases: [
    'Legacy client modernization',
    'Polyglot systems',
    'External service access',
    'Connectivity patterns',
  ],
  tags: ['integration', 'proxy', 'connectivity', 'offload'],
  structure: createPatternStructure({
    minNodes: 3,
    requiredNodeTypes: ['http-request'],
    optionalNodeTypes: ['retry', 'circuit-breaker'],
    requiredEdges: [createEdgePattern('client', 'ambassador', 'sequential')],
    topology: 'linear',
    constraints: [PatternConstraints.nodeCount(3)],
  }),
  examples: [],
  antiPatterns: ['direct-external-calls'],
  relatedPatterns: ['sidecar', 'proxy'],
  documentation: 'Proxy handles connectivity concerns for clients.',
});

/**
 * All integration patterns
 */
export const INTEGRATION_PATTERNS: PatternDefinition[] = [
  API_GATEWAY,
  BACKEND_FOR_FRONTEND,
  SERVICE_MESH,
  ADAPTER,
  FACADE,
  WEBHOOK_INTEGRATION,
  ANTI_CORRUPTION_LAYER,
  STRANGLER_FIG,
  SIDECAR,
  AMBASSADOR,
];

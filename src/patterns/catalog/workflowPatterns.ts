/**
 * Workflow Patterns (11 patterns)
 * Process orchestration and control flow patterns
 */

import type { PatternDefinition } from '../../types/patterns';
import {
  createPatternDefinition,
  createPatternStructure,
  createEdgePattern,
  PatternConstraints,
} from '../PatternDefinition';

export const SAGA: PatternDefinition = createPatternDefinition({
  id: 'saga',
  name: 'Saga Pattern',
  category: 'workflow',
  complexity: 'expert',
  description: 'Manage distributed transactions using sequence of local transactions',
  problem: 'Distributed transactions across services are complex',
  solution:
    'Break into local transactions with compensating actions for rollback',
  benefits: [
    'Distributed transaction support',
    'Eventual consistency',
    'Failure handling',
    'Scalability',
  ],
  tradeoffs: [
    'Complex implementation',
    'Compensation logic',
    'Testing difficulty',
    'Debugging challenges',
  ],
  useCases: [
    'Order processing',
    'Booking systems',
    'Payment processing',
    'Multi-step workflows',
  ],
  tags: ['workflow', 'saga', 'transaction', 'distributed'],
  structure: createPatternStructure({
    minNodes: 5,
    requiredNodeTypes: ['http-request', 'switch'],
    optionalNodeTypes: ['compensate', 'function'],
    requiredEdges: [
      createEdgePattern('step', 'next-or-compensate', 'conditional'),
      createEdgePattern('fail', 'compensate', 'error'),
    ],
    topology: 'dag',
    constraints: [PatternConstraints.nodeCount(5)],
  }),
  examples: [],
  antiPatterns: ['no-compensation', 'inconsistent-state'],
  relatedPatterns: ['compensating-transaction', 'orchestration'],
  documentation: 'Manages distributed transactions with compensation.',
});

export const ORCHESTRATION: PatternDefinition = createPatternDefinition({
  id: 'orchestration',
  name: 'Orchestration Pattern',
  category: 'workflow',
  complexity: 'advanced',
  description: 'Central coordinator manages workflow execution',
  problem: 'Need to coordinate complex multi-step workflows',
  solution: 'Central orchestrator controls execution flow and handles coordination',
  benefits: [
    'Central control',
    'Clear workflow',
    'Error handling',
    'Monitoring',
  ],
  tradeoffs: [
    'Single point of failure',
    'Orchestrator complexity',
    'Tight coupling',
    'Scalability limits',
  ],
  useCases: [
    'Business processes',
    'Multi-service workflows',
    'Complex coordination',
    'Process automation',
  ],
  tags: ['workflow', 'orchestration', 'coordination', 'central'],
  structure: createPatternStructure({
    minNodes: 4,
    requiredNodeTypes: ['http-request', 'switch'],
    optionalNodeTypes: ['function'],
    requiredEdges: [createEdgePattern('orchestrator', 'service', 'sequential')],
    topology: 'star',
    constraints: [PatternConstraints.nodeCount(4)],
  }),
  examples: [],
  antiPatterns: ['god-orchestrator', 'tight-coupling'],
  relatedPatterns: ['choreography', 'saga'],
  documentation: 'Central orchestrator coordinates workflow execution.',
});

export const CHOREOGRAPHY: PatternDefinition = createPatternDefinition({
  id: 'choreography',
  name: 'Choreography Pattern',
  category: 'workflow',
  complexity: 'advanced',
  description: 'Decentralized coordination through events',
  problem: 'Orchestration creates tight coupling and single point of failure',
  solution: 'Services coordinate by publishing and subscribing to events',
  benefits: [
    'Loose coupling',
    'No single point of failure',
    'Scalability',
    'Independence',
  ],
  tradeoffs: [
    'Complex monitoring',
    'Hard to understand flow',
    'Debugging difficulty',
    'Eventual consistency',
  ],
  useCases: [
    'Event-driven workflows',
    'Microservices',
    'Reactive systems',
    'Decentralized processes',
  ],
  tags: ['workflow', 'choreography', 'event-driven', 'decentralized'],
  structure: createPatternStructure({
    minNodes: 4,
    requiredNodeTypes: ['webhook', 'http-request'],
    optionalNodeTypes: ['event-bus', 'pubsub'],
    requiredEdges: [createEdgePattern('service', 'event', 'sequential')],
    topology: 'mesh',
    constraints: [PatternConstraints.nodeCount(4)],
  }),
  examples: [],
  antiPatterns: ['hidden-dependencies', 'no-tracing'],
  relatedPatterns: ['event-driven', 'saga'],
  documentation: 'Services coordinate through event publication and subscription.',
});

export const FAN_OUT_FAN_IN: PatternDefinition = createPatternDefinition({
  id: 'fan-out-fan-in',
  name: 'Fan-Out/Fan-In',
  category: 'workflow',
  complexity: 'intermediate',
  description: 'Split work across parallel processors then merge results',
  problem: 'Need to process large workload quickly',
  solution: 'Distribute work to multiple parallel processors, then aggregate results',
  benefits: [
    'Parallel processing',
    'Faster execution',
    'Scalability',
    'Resource utilization',
  ],
  tradeoffs: [
    'Aggregation complexity',
    'Synchronization',
    'Partial failures',
    'Resource coordination',
  ],
  useCases: [
    'Batch processing',
    'Map-reduce',
    'Parallel queries',
    'Image processing',
  ],
  tags: ['workflow', 'parallel', 'distribution', 'aggregation'],
  structure: createPatternStructure({
    minNodes: 4,
    requiredNodeTypes: ['split', 'merge'],
    optionalNodeTypes: ['function', 'http-request'],
    requiredEdges: [
      createEdgePattern('split', 'worker', 'parallel'),
      createEdgePattern('worker', 'merge', 'sequential'),
    ],
    topology: 'dag',
    constraints: [PatternConstraints.nodeCount(4)],
  }),
  examples: [],
  antiPatterns: ['sequential-when-parallel-possible', 'no-error-handling'],
  relatedPatterns: ['scatter-gather', 'map-reduce'],
  documentation: 'Distributes work in parallel then merges results.',
});

export const PRIORITY_QUEUE: PatternDefinition = createPatternDefinition({
  id: 'priority-queue',
  name: 'Priority Queue',
  category: 'workflow',
  complexity: 'intermediate',
  description: 'Process items based on priority rather than arrival order',
  problem: 'Some tasks are more important and should be processed first',
  solution: 'Use priority queue to ensure high-priority items are processed first',
  benefits: [
    'Priority handling',
    'SLA compliance',
    'Resource optimization',
    'Fair scheduling',
  ],
  tradeoffs: [
    'Starvation risk',
    'Complexity',
    'Priority management',
    'Queue overhead',
  ],
  useCases: [
    'Task scheduling',
    'Request processing',
    'Order fulfillment',
    'Alert handling',
  ],
  tags: ['workflow', 'queue', 'priority', 'scheduling'],
  structure: createPatternStructure({
    minNodes: 3,
    requiredNodeTypes: ['webhook', 'switch'],
    optionalNodeTypes: ['queue', 'redis'],
    requiredEdges: [createEdgePattern('enqueue', 'process-by-priority', 'conditional')],
    topology: 'branching',
    constraints: [PatternConstraints.nodeCount(3)],
  }),
  examples: [],
  antiPatterns: ['fifo-only', 'priority-inversion'],
  relatedPatterns: ['message-queue', 'scheduling'],
  documentation: 'Processes items based on priority rather than order.',
});

export const BATCH_PROCESSING: PatternDefinition = createPatternDefinition({
  id: 'batch-processing',
  name: 'Batch Processing',
  category: 'workflow',
  complexity: 'intermediate',
  description: 'Process data in batches for efficiency',
  problem: 'Processing items individually is inefficient',
  solution: 'Collect items into batches and process together',
  benefits: [
    'Efficient processing',
    'Reduced overhead',
    'Better throughput',
    'Resource optimization',
  ],
  tradeoffs: [
    'Increased latency',
    'Batch size tuning',
    'Partial failures',
    'Memory usage',
  ],
  useCases: [
    'Database bulk operations',
    'Email sending',
    'Report generation',
    'Data import',
  ],
  tags: ['workflow', 'batch', 'bulk', 'efficiency'],
  structure: createPatternStructure({
    minNodes: 3,
    requiredNodeTypes: ['aggregate', 'function'],
    optionalNodeTypes: ['schedule', 'database'],
    requiredEdges: [createEdgePattern('collect', 'process-batch', 'sequential')],
    topology: 'linear',
    constraints: [PatternConstraints.nodeCount(3)],
  }),
  examples: [],
  antiPatterns: ['one-at-a-time', 'no-batching'],
  relatedPatterns: ['bulk-operations', 'scheduling'],
  documentation: 'Collects and processes items in batches for efficiency.',
});

export const SCHEDULED_WORKFLOW: PatternDefinition = createPatternDefinition({
  id: 'scheduled-workflow',
  name: 'Scheduled Workflow',
  category: 'workflow',
  complexity: 'beginner',
  description: 'Execute workflows on a schedule',
  problem: 'Need to run workflows at specific times or intervals',
  solution: 'Use cron-like scheduler to trigger workflows',
  benefits: [
    'Automated execution',
    'Predictable timing',
    'Resource planning',
    'Hands-off operation',
  ],
  tradeoffs: [
    'Schedule management',
    'Missed executions',
    'Timezone handling',
    'Overlap prevention',
  ],
  useCases: [
    'Nightly reports',
    'Data synchronization',
    'Cleanup tasks',
    'Monitoring checks',
  ],
  tags: ['workflow', 'schedule', 'cron', 'automation'],
  structure: createPatternStructure({
    minNodes: 2,
    requiredNodeTypes: ['schedule'],
    optionalNodeTypes: ['function', 'http-request'],
    requiredEdges: [createEdgePattern('schedule', 'execute', 'sequential')],
    topology: 'linear',
    constraints: [PatternConstraints.requiresNodeType('schedule')],
  }),
  examples: [],
  antiPatterns: ['manual-execution-only', 'no-error-notification'],
  relatedPatterns: ['cron', 'batch-processing'],
  documentation: 'Triggers workflow execution on a schedule.',
});

export const CONDITIONAL_WORKFLOW: PatternDefinition = createPatternDefinition({
  id: 'conditional-workflow',
  name: 'Conditional Workflow',
  category: 'workflow',
  complexity: 'beginner',
  description: 'Branch execution based on conditions',
  problem: 'Different scenarios require different processing',
  solution: 'Use conditional logic to route to appropriate branches',
  benefits: [
    'Flexible logic',
    'Context-aware',
    'Efficient execution',
    'Clear branching',
  ],
  tradeoffs: [
    'Complex conditions',
    'Testing all paths',
    'Maintenance',
    'Debugging',
  ],
  useCases: [
    'Approval workflows',
    'Data routing',
    'Error handling',
    'Business logic',
  ],
  tags: ['workflow', 'conditional', 'branching', 'logic'],
  structure: createPatternStructure({
    minNodes: 2,
    requiredNodeTypes: ['if', 'switch'],
    optionalNodeTypes: ['function'],
    requiredEdges: [createEdgePattern('condition', 'branch', 'conditional')],
    topology: 'branching',
    constraints: [PatternConstraints.nodeCount(2)],
  }),
  examples: [],
  antiPatterns: ['complex-conditions', 'nested-conditions'],
  relatedPatterns: ['content-based-router', 'switch-case'],
  documentation: 'Routes execution based on conditional logic.',
});

export const PARALLEL_WORKFLOW: PatternDefinition = createPatternDefinition({
  id: 'parallel-workflow',
  name: 'Parallel Workflow',
  category: 'workflow',
  complexity: 'intermediate',
  description: 'Execute multiple branches concurrently',
  problem: 'Sequential execution is too slow',
  solution: 'Split into parallel branches that execute concurrently',
  benefits: [
    'Faster execution',
    'Better throughput',
    'Resource utilization',
    'Scalability',
  ],
  tradeoffs: [
    'Synchronization complexity',
    'Resource contention',
    'Error handling',
    'Debugging difficulty',
  ],
  useCases: [
    'Independent tasks',
    'Parallel API calls',
    'Multi-channel notification',
    'Concurrent processing',
  ],
  tags: ['workflow', 'parallel', 'concurrent', 'performance'],
  structure: createPatternStructure({
    minNodes: 3,
    requiredNodeTypes: ['split'],
    optionalNodeTypes: ['merge', 'function'],
    requiredEdges: [createEdgePattern('split', 'branch', 'parallel')],
    topology: 'dag',
    constraints: [PatternConstraints.nodeCount(3)],
  }),
  examples: [],
  antiPatterns: ['sequential-when-parallel-possible', 'no-synchronization'],
  relatedPatterns: ['fan-out-fan-in', 'scatter-gather'],
  documentation: 'Executes multiple branches concurrently.',
});

export const SEQUENTIAL_WORKFLOW: PatternDefinition = createPatternDefinition({
  id: 'sequential-workflow',
  name: 'Sequential Workflow',
  category: 'workflow',
  complexity: 'beginner',
  description: 'Execute steps one after another in order',
  problem: 'Steps must happen in specific order',
  solution: 'Chain steps sequentially where output feeds next input',
  benefits: [
    'Simple to understand',
    'Predictable execution',
    'Easy debugging',
    'Clear dependencies',
  ],
  tradeoffs: [
    'Slower execution',
    'No parallelization',
    'Blocking',
    'Limited scalability',
  ],
  useCases: [
    'Linear pipelines',
    'Dependent steps',
    'State machines',
    'Multi-step forms',
  ],
  tags: ['workflow', 'sequential', 'linear', 'simple'],
  structure: createPatternStructure({
    minNodes: 2,
    requiredNodeTypes: [],
    optionalNodeTypes: ['function', 'http-request'],
    requiredEdges: [createEdgePattern('step', 'next-step', 'sequential')],
    topology: 'linear',
    constraints: [PatternConstraints.nodeCount(2), PatternConstraints.noCycles()],
  }),
  examples: [],
  antiPatterns: ['unnecessary-sequential', 'blocking-operations'],
  relatedPatterns: ['pipeline', 'chain-of-responsibility'],
  documentation: 'Executes steps sequentially in order.',
});

export const LOOP_WORKFLOW: PatternDefinition = createPatternDefinition({
  id: 'loop-workflow',
  name: 'Loop Workflow',
  category: 'workflow',
  complexity: 'intermediate',
  description: 'Repeat execution until condition is met',
  problem: 'Need to repeat operations multiple times',
  solution: 'Use loop structure with exit condition',
  benefits: [
    'Repetitive tasks',
    'Iteration support',
    'Conditional exit',
    'Flexible',
  ],
  tradeoffs: [
    'Infinite loop risk',
    'Performance impact',
    'Complexity',
    'Hard to debug',
  ],
  useCases: [
    'Polling',
    'Retry until success',
    'Batch iteration',
    'Data processing',
  ],
  tags: ['workflow', 'loop', 'iteration', 'repeat'],
  structure: createPatternStructure({
    minNodes: 3,
    requiredNodeTypes: ['switch', 'function'],
    optionalNodeTypes: ['delay'],
    requiredEdges: [
      createEdgePattern('condition', 'execute-or-exit', 'conditional'),
      createEdgePattern('execute', 'condition', 'sequential'),
    ],
    topology: 'loop',
    constraints: [PatternConstraints.nodeCount(3)],
  }),
  examples: [],
  antiPatterns: ['infinite-loop', 'no-exit-condition'],
  relatedPatterns: ['while-loop', 'retry'],
  documentation: 'Repeats execution until condition is met.',
});

/**
 * All workflow patterns
 */
export const WORKFLOW_PATTERNS: PatternDefinition[] = [
  SAGA,
  ORCHESTRATION,
  CHOREOGRAPHY,
  FAN_OUT_FAN_IN,
  PRIORITY_QUEUE,
  BATCH_PROCESSING,
  SCHEDULED_WORKFLOW,
  CONDITIONAL_WORKFLOW,
  PARALLEL_WORKFLOW,
  SEQUENTIAL_WORKFLOW,
  LOOP_WORKFLOW,
];
